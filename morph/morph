#!/bin/bash

if ! [[ $MORPH_DIR ]]; then
    if [[ -d /usr/share/morph ]]; then
        MORPH_DIR=/usr/share/morph
    else
        MORPH_DIR=$(dirname $(readlink -f $0))
    fi
fi

if [[ -z $MORPH_DEBUG ]]; then
    MORPH_DEBUG=0
fi

. $MORPH_DIR/morphrc
. $MORPH_DIR/lib/debug

validate () {
    if [[ -z "$name" ]]; then
        die "Package name is not set!"
    fi
    if [[ -z "$version" ]]; then
        die "Version is not set!"
    fi
    if [[ -z "$mbuild" ]]; then
        warn "Build is not set. Using build=1 by default"
        mbuild=1
    fi
    if [[ -z "$arch" ]]; then
        warn "Arch is not set. Using arch=any by default"
        arch=any
    fi
    if [[ -z "$description" ]]; then
        die "Description is not set!"
    fi
    if [[ -z "$source" ]]; then
        warn "Source is not set. Is that what you really want?"
    fi
    if [[ -z "$tags" ]]; then
        warn "Tags are not set. No one will find your package."
    fi
    if [[ -z "$depends" ]]; then
        warn "depends is not set. Using depends=auto by default."
        depends=auto
    fi

    if [[ -z $target_arch ]]; then
        target_arch="$(uname -m)"
    fi

    if [[ "$arch" == "any" ]]; then
        arch=$target_arch
    elif [[ "$arch" == "noarch" ]]; then
        arch=none
    else
        for item in $arch; do
            if [[ "$item" == "$target_arch" ]]; then
                supported=1
                break
            fi
        done
        if ! [[ $supported ]]; then
            die "Unsupported architecture: $target_arch"
        fi
    fi
}

init_structure () {
    export tmpdir=$(mktemp -d /tmp/morph.XXXXXXXX)
    export srcdir="$tmpdir/source"
    export pkgdir="$tmpdir/out/main"
    for item in $subpackages; do
        mkdir -p $tmpdir/out/$item
    done
    mkdir -p $srcdir
    mkdir -p $pkgdir
    mkdir -p $source_cache_dir
    mkdir -p $package_out_dir
}

process_source () {
    source_item=$1

    protocol=$(echo $source_item | cut "-d:" -f1)
    source_url=$(echo $source_item | sed "s/${protocol}://")

    loader=$MORPH_DIR/loaders/$protocol
    if [[ -f "$loader" ]]; then
        . "$loader"
    else
        die "No loader found for protocol $protocol"
    fi

    srcpath=$source_cache_dir/$name/
    if [[ $returns_dir ]]; then
        srcpath=$srcpath/$(basename $source_url)
    fi

    mkdir -p $srcpath
    cd $srcpath

    if check; then
        update
    else
        init
    fi
    
    cd $srcdir

    if [[ $returns_dir ]]; then
        if is_function prepare_source; then
            cd $srcpath
            prepare_source
            cd $srcdir
        fi
        shopt -s dotglob
        cp -r $srcpath/* .
        shopt -u dotglob
        unpacked=1
    else
        source_file=$srcpath/$(basename $source_url)
        for unpacker in $(find $MORPH_DIR/unpackers -type f); do
            . $unpacker
            if check; then
                debug "Using unpacker $unpacker"
                unpack
                unpacked=1
                break
            fi
        done
    fi
    
    if ! [[ $unpacked ]]; then
        die "Failed to unpack!"
    fi
}

is_function () {
    declare -f $1 > /dev/null
}

do_autobuild () {
    if ! [[ -f $MORPH_DIR/builders/$1 ]]; then
        die "No such builder: $1"
    fi
    . $MORPH_DIR/builders/$1
    if check; then
        debug "Using builder $1"
        build || false
    else
        false
    fi
}

autobuild () {
    if [[ $1 ]]; then
        do_autobuild $1 && built=1
    else
        for builder in $(find $MORPH_DIR/builders -type f); do
            if do_autobuild $(basename $builder); then
                debug "Built using $builder"
                built=1
                break
            fi
        done
    fi
    if ! [[ "$built" ]]; then
        die "Failed to autobuild!"
    fi
}

go_src_dir () {
    cd $srcdir
    # TODO advanced heuristics :)
    if [[ -d $name-$version ]]; then
        cd $name-$version
    fi
}

set_flags () {
    num_cpu_cores=$(cat /proc/cpuinfo | grep processor | wc -l)
    if ! [[ $make_threads ]]; then
        make_threads=$(($num_cpu_cores + 1))
    fi
    make_flags="-j$make_threads $make_flags"
    if which ccache &> /dev/null; then
        if [[ "$ccache" != "0" ]]; then
            if ! [[ $ccache ]]; then
                ccache="4G"
            fi
            if ! [[ $ccache_path ]]; then
                ccache_path=~/.morph/ccache
            fi
            export CCACHE_DIR=$ccache_path/$target_arch/
            mkdir -p $CCACHE_DIR
            ccache -M $ccache
            # TODO not cross friendly
            export CC="$(which ccache) gcc"
            export CXX="$(which ccache) g++"
        fi
    fi
}

# Options:
# -t, --tree       -- use a build tree
# -i, --install    -- install package after building
# -h, --help       -- show help message
# -s, --spawn      -- spawn a new MORPHLING here
# --version        -- set version
# --build          -- set build
# --target-arch    -- set target arch (for cross)

# Options parsing black magic
argv=$(getopt -s bash --options "t:ihs" --longoptions tree:,install,help,spawn,version:,build:,target-arch: -n Morph -- $@)
eval set -- "$argv"

declare -i positional_count=0
positional_args=""

while [[ $1 ]]; do
    if [[ $positionals ]]; then
        positional_count=$(($positional_count + 1))
        positional_args="$1"
    else
        case $1 in
            -t|--tree)
                shift
                build_tree=$(dirname $1)/$(basename $1)
                ;;
            -i|--install)
                will_install=1
                ;;
            -h|--help)
                show_help
                ;;
            -s|--spawn)
                if [[ -f MORPHLING ]]; then
                    die "There is a MORPHLING here already!"
                fi
                cp $MORPH_DIR/SAMPLE MORPHLING
                exit 0
                ;;
            --version)
                shift
                # TODO bump magic
                ;;
            --build)
                shift
                # TODO bump magic
                ;;
            --target-arch)
                shift
                target_arch=$1
                ;;
            --)
                positionals=1
                ;;
        esac
    fi
    shift
done

if [[ $build_tree ]]; then
    if [[ $positional_count -gt 0 ]]; then
        die "Can't have --tree and positional args at the same time"
    else
        tree_path=$(mktemp -d /tmp/morph-tree.XXXXXX)
        cd $tree_path
        tar xf $build_tree
        path=$(pwd)
    fi
else
    if [[ "$positional_count" -gt 1 ]]; then
        die "Too many positional arguments!"
    elif [[ "$positional_count" == "1" ]]; then
        if [[ -d $positional_args ]]; then
            path=$positional_args
        else
            die "$positional_args is not a directory!"
        fi
    else
        path=$(pwd)
    fi
fi

if ! [[ -f $path/MORPHLING ]]; then
    die "No MORPHLING found in $path!"
fi

. $path/MORPHLING
validate

init_structure

for item in $source; do
    process_source $item
done

go_src_dir

set_flags

if is_function build; then
    build
elif [[ $autobuild ]]; then
    autobuild $autobuild
else
    autobuild
fi

for packager in $(find $MORPH_DIR/packagers -type f -executable); do
    . $packager
    package
done

rm -rf $tmpdir
